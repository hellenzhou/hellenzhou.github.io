<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="引言 &amp;emsp;&amp;emsp; 考虑下面的结构体定义：    123456typedef struct&amp;#123;   char  c1;   short s;    char  c2;    int   i;&amp;#125;T_FOO; &amp;emsp;&amp;emsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。  &amp;emsp;&amp;emsp;">
<meta property="og:type" content="article">
<meta property="og:title" content="字节对齐">
<meta property="og:url" content="https://hellenzhou.github.io/2017/11/25/字节对齐/index.html">
<meta property="og:site_name" content="技术文章记录">
<meta property="og:description" content="引言 &amp;emsp;&amp;emsp; 考虑下面的结构体定义：    123456typedef struct&amp;#123;   char  c1;   short s;    char  c2;    int   i;&amp;#125;T_FOO; &amp;emsp;&amp;emsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。  &amp;emsp;&amp;emsp;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://hellenzhou.github.io/2017/11/25/字节对齐/181344177568936.jpg">
<meta property="og:updated_time" content="2017-11-27T03:12:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="字节对齐">
<meta name="twitter:description" content="引言 &amp;emsp;&amp;emsp; 考虑下面的结构体定义：    123456typedef struct&amp;#123;   char  c1;   short s;    char  c2;    int   i;&amp;#125;T_FOO; &amp;emsp;&amp;emsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。  &amp;emsp;&amp;emsp;">
<meta name="twitter:image" content="https://hellenzhou.github.io/2017/11/25/字节对齐/181344177568936.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hellenzhou.github.io/2017/11/25/字节对齐/"/>





  <title>字节对齐 | 技术文章记录</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">技术文章记录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2017/11/25/字节对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">字节对齐</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-25T19:38:38+08:00">
                2017-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p> &emsp;&emsp; 考虑下面的结构体定义：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  c1;</span><br><span class="line">   <span class="keyword">short</span> s; </span><br><span class="line">   <span class="keyword">char</span>  c2; </span><br><span class="line">   <span class="keyword">int</span>   i;</span><br><span class="line">&#125;T_FOO;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。</p>
<p> &emsp;&emsp;现在，我们编写一个简单的程序：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    T_FOO a; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1 -&gt; %d, s -&gt; %d, c2 -&gt; %d, i -&gt; %d\n"</span>, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c1 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.s  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c2 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.i  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp; &emsp;&emsp;运行后输出：<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 -&gt; <span class="number">0</span>, s -&gt; <span class="number">2</span>, c2 -&gt; <span class="number">4</span>, i -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;为什么会这样？这就是字节对齐导致的问题。</p>
<p>&emsp;&emsp;本文在参考诸多资料的基础上，详细介绍常见的字节对齐问题。因成文较早，资料来源大多已不可考，敬请谅解。</p>
<h3 id="一-什么是字节对齐"><a href="#一-什么是字节对齐" class="headerlink" title="一  什么是字节对齐"></a>一  什么是字节对齐</h3><p>&emsp;&emsp; 现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</p>
<h3 id="二-对齐的原因和作用"><a href="#二-对齐的原因和作用" class="headerlink" title="二  对齐的原因和作用"></a>二  对齐的原因和作用</h3><p>&emsp;&emsp;不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。</p>
<p>&emsp;&emsp; 但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。</p>
<p>&emsp;&emsp; 因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。</p>
<p>&emsp;&emsp;此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。</p>
<h3 id="三-对齐的分类和准则"><a href="#三-对齐的分类和准则" class="headerlink" title="三  对齐的分类和准则"></a>三  对齐的分类和准则</h3><p>&emsp;&emsp; 主要基于Intel X86架构介绍结构体对齐和栈内存对齐，位域本质上为结构体类型。</p>
<p>&emsp;&emsp; 对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。</p>
<h4 id="3-1-结构体对齐"><a href="#3-1-结构体对齐" class="headerlink" title="3.1 结构体对齐"></a>3.1 结构体对齐</h4><p>&emsp;&emsp;在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</p>
<p>&emsp;&emsp;字节对齐的问题主要就是针对结构体。</p>
<h4 id="3-1-1-简单示例"><a href="#3-1-1-简单示例" class="headerlink" title="3.1.1 简单示例"></a>3.1.1 简单示例</h4><p>&emsp;&emsp;先看个简单的例子(32位，X86处理器，GCC编译器)：</p>
<p>&emsp;&emsp;【例1】设结构体如下定义：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span>    a;</span><br><span class="line">     <span class="keyword">char</span>   b;</span><br><span class="line">     <span class="keyword">short</span>  c;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">     <span class="keyword">char</span>   b;</span><br><span class="line">     <span class="keyword">int</span>    a;</span><br><span class="line">     <span class="keyword">short</span>  c;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？</p>
<p>&emsp;&emsp;结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。 </p>
<p>&emsp;&emsp;结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。 </p>
<h4 id="3-1-2-对齐准则"><a href="#3-1-2-对齐准则" class="headerlink" title="3.1.2 对齐准则"></a>3.1.2 对齐准则</h4><p>&emsp;&emsp;先来看四个重要的基本概念：</p>
<p>&emsp;&emsp;1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。</p>
<p>&emsp;&emsp;2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。</p>
<p>&emsp;&emsp;3) 指定对齐值：#pragma pack (value)时的指定对齐值value。</p>
<p>&emsp;&emsp;4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=<font color="#FF7F50">min{自身对齐值，当前指定的pack值}。</font></p>
<p>&emsp;&emsp;基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。</p>
<p>&emsp;&emsp;其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。</p>
<p>&emsp;&emsp;以此分析3.1.1节中的结构体B：</p>
<p>&emsp;&emsp;假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。</p>
<p>&emsp;&emsp;再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)=12。</p>
<p>&emsp;&emsp;之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。 </p>
<p>&emsp;&emsp;上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。</p>
<p>&emsp;&emsp;结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：</p>
<p>&emsp;&emsp;<font color="#FF7F50">1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</font></p>
<p>&emsp;&emsp;对于以上规则的说明如下：</p>
<p>&emsp;&emsp;<font color="#FF7F50">第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</font></p>
<p>&emsp;&emsp;【例2】假设4字节对齐，以下程序的输出结果是多少？</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OFFSET宏定义可取得指定结构体某成员在结构体内部的偏移 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  a;</span><br><span class="line">   <span class="keyword">short</span> b;</span><br><span class="line">   <span class="keyword">char</span>  c;</span><br><span class="line">   <span class="keyword">int</span>   d;</span><br><span class="line">  <span class="keyword">char</span>  e[<span class="number">3</span>];</span><br><span class="line">&#125;T_Test;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Size = %d\n  a-%d, b-%d, c-%d, d-%d\n  e[0]-%d, e[1]-%d, e[2]-%d\n"</span>,</span><br><span class="line">          <span class="keyword">sizeof</span>(T_Test), OFFSET(T_Test, a), OFFSET(T_Test, b),</span><br><span class="line">          OFFSET(T_Test, c), OFFSET(T_Test, d), OFFSET(T_Test, e[<span class="number">0</span>]),</span><br><span class="line">         OFFSET(T_Test, e[<span class="number">1</span>]),OFFSET(T_Test, e[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 执行后输出如下：   </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size = <span class="number">16</span></span><br><span class="line">a<span class="number">-0</span>, b<span class="number">-2</span>, c<span class="number">-4</span>, d<span class="number">-8</span></span><br><span class="line">e[<span class="number">0</span>]<span class="number">-12</span>, e[<span class="number">1</span>]<span class="number">-13</span>, e[<span class="number">2</span>]<span class="number">-14</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面来具体分析：</p>
<p>&emsp;&emsp;首先char a占用1个字节，没问题。</p>
<p>&emsp;&emsp;short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。</p>
<p>&emsp;&emsp;char c占用1个字节，没问题。</p>
<p>&emsp;&emsp;int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。</p>
<p>&emsp;&emsp;char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。</p>
<p>&emsp;&emsp;因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。</p>
<h4 id="3-1-3-对齐的隐患"><a href="#3-1-3-对齐的隐患" class="headerlink" title="3.1.3 对齐的隐患"></a>3.1.3 对齐的隐患</h4><h4 id="3-1-3-1-数据类型转换"><a href="#3-1-3-1-数据类型转换" class="headerlink" title="3.1.3.1 数据类型转换"></a>3.1.3.1 数据类型转换</h4><p>&emsp;&emsp;代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line">         </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">      *p = <span class="number">0x00</span>;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> *p1 = (<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">      *p1 = <span class="number">0x0000</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。</p>
<p>&emsp;&emsp;又如对于3.1.1节的结构体struct B，定义如下函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">       <span class="comment">//Code</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在函数体内如果直接访问p-&gt;a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p-&gt;a的地址很可能不是4的倍数。</p>
<p>&emsp;&emsp;如果p的地址不在对齐边界上就可能出问题，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。 </p>
<p>&emsp;&emsp;解决方式如下：<br>&emsp;&emsp;1) 定义一个此结构的局部变量，用memmove方式将数据拷贝进来。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">tData</span>;</span></span><br><span class="line">   memmove(&amp;tData, p, <span class="keyword">sizeof</span>(struct B));</span><br><span class="line">  <span class="comment">//此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定(比如跨CPU输入数据、或指针移位运算出来的数据要特别小心)，则需要这样处理。</p>
<p>&emsp;&emsp;2) 用#pragma pack (1)将STRUCT_T定义为1字节对齐方式。</p>
<h4 id="3-1-3-2-处理器间数据通信"><a href="#3-1-3-2-处理器间数据通信" class="headerlink" title="3.1.3.2 处理器间数据通信"></a>3.1.3.2 处理器间数据通信</h4><p>&emsp;&emsp;处理器间通过消息(对于C/C++而言就是结构体)进行通信时，需要注意字节对齐以及字节序的问题。</p>
<p>&emsp;&emsp;大多数编译器提供内存对其的选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如C/C++编译器提供的#pragma pack(n) n=1，2，4等，让编译器在生成目标文件时，使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处。</p>
<p>&emsp;&emsp;然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。 </p>
<p>&emsp;&emsp;下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。</p>
<p>&emsp;&emsp;对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。</p>
<p>&emsp;&emsp;对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行四字节对齐。</p>
<p>&emsp;&emsp;数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。顺序安排原则是：四字节的放在最前面，两字节的紧接最后一个四字节成员，一字节紧接最后一个两字节成员，填充字节放在最后。</p>
<p>&emsp;&emsp;举例如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_T_MSG</span>&#123;</span></span><br><span class="line">     <span class="keyword">long</span>  ParaA;</span><br><span class="line">     <span class="keyword">long</span>  ParaB;</span><br><span class="line">     <span class="keyword">short</span> ParaC；</span><br><span class="line">     <span class="keyword">char</span>  ParaD;</span><br><span class="line">     <span class="keyword">char</span>  Pad;   <span class="comment">//填充字节</span></span><br><span class="line"> &#125;T_MSG;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-3-排查对齐问题"><a href="#3-1-3-3-排查对齐问题" class="headerlink" title="3.1.3.3 排查对齐问题"></a>3.1.3.3 排查对齐问题</h4><p>&emsp;&emsp;如果出现对齐或者赋值问题可查看：</p>
<p>&emsp;&emsp;1) 编译器的字节序大小端设置；</p>
<p>&emsp;&emsp;2) 处理器架构本身是否支持非对齐访问；</p>
<p>&emsp;&emsp;3) 如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 </p>
<h4 id="3-1-4-更改对齐方式"><a href="#3-1-4-更改对齐方式" class="headerlink" title="3.1.4 更改对齐方式"></a>3.1.4 更改对齐方式</h4><p>&emsp;&emsp;主要是更改C编译器的缺省字节对齐方式。   </p>
<p>&emsp;&emsp; 在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p>
<p>&emsp;&emsp;使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；<br>&emsp;&emsp;使用伪指令#pragma pack()： 取消自定义字节对齐方式。<br>&emsp;&emsp;另外，还有如下的一种方式(GCC特有语法)：</p>
<ul>
<li>&emsp;&emsp;__attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。</li>
<li>&emsp;&emsp;<strong>attribute</strong> ((packed))： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</li>
</ul>
<p>&emsp;&emsp;【注】<strong>attribute</strong>机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。详细介绍请参考：</p>
<p>  &emsp;&emsp;<a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html" target="_blank" rel="noopener">http://www.unixwiz.net/techtips/gnu-c-attributes.html</a></p>
<p>&emsp;&emsp;下面具体针对MS VC/C++ 6.0编译器介绍下如何修改编译器默认对齐值。</p>
<p> &emsp;&emsp;1) VC/C++ IDE环境中，可在[Project]|[Settings]，C/C++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</p>
<p>&emsp;&emsp;&emsp;&emsp;<img src="/2017/11/25/字节对齐/181344177568936.jpg" alt=""></p>
<p>&emsp;&emsp;VC/C++中的编译选项有/Zp[1|2|4|8|16]，/Zpn表示以n字节边界对齐。n字节边界对齐是指一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。亦即：min(sizeof(member), n)。</p>
<p>&emsp;&emsp;实际上，1字节边界对齐也就表示结构成员之间没有空洞。</p>
<p>&emsp;&emsp;/Zpn选项应用于整个工程，影响所有参与编译的结构体。在Struct member alignment中可选择不同的对齐值来改变编译选项。</p>
<p>&emsp;&emsp;2) 在编码时，可用#pragma pack动态修改对齐值。具体语法说明见附录5.3节。</p>
<p>&emsp;&emsp;自定义对齐值后要用#pragma pack()来还原，否则会对后面的结构造成影响。 </p>
<p>&emsp;&emsp;【例3】分析如下结构体C：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">pragma</span> pack(2)  <span class="comment">//指定按2字节对齐</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">      <span class="keyword">char</span>  b;</span><br><span class="line">      <span class="keyword">int</span>   a;</span><br><span class="line">      <span class="keyword">short</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">//取消指定对齐，恢复缺省对齐</span></span></span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;变量b自身对齐值为<span class="number">1</span>，指定对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">1</span>，假设C从<span class="number">0x0000</span>开始，则b存放在<span class="number">0x0000</span>，符合<span class="number">0x0000</span>%<span class="number">1</span>= <span class="number">0</span>；变量a自身对齐值为<span class="number">4</span>，指定对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">2</span>，顺序存放在<span class="number">0x0002</span>~<span class="number">0x0005</span>四个连续字节中，符合<span class="number">0x0002</span>%<span class="number">2</span>=<span class="number">0</span>。变量c的自身对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">2</span>，顺序存放在<span class="number">0x0006</span>~<span class="number">0x0007</span>中，符合 <span class="number">0x0006</span>%<span class="number">2</span>=<span class="number">0</span>。所以从<span class="number">0x0000</span>到<span class="number">0x00007</span>共八字节存放的是C的变量。C的自身对齐值为<span class="number">4</span>，所以其有效对齐值为<span class="number">2</span>。又<span class="number">8</span>%<span class="number">2</span>=<span class="number">0</span>，C只占用<span class="number">0x0000</span>~<span class="number">0x0007</span>的八个字节。所以<span class="keyword">sizeof</span>(struct C) = <span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;注意，结构体对齐到的字节数并非完全取决于当前指定的pack值，如下：</span><br><span class="line"> </span><br><span class="line"> ```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">      <span class="keyword">char</span>  b;</span><br><span class="line">      <span class="keyword">short</span> a;</span><br><span class="line">      <span class="keyword">char</span>  c;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时sizeof(struct C)的值为7。</p>
<h4 id="3-2-栈内存对齐"><a href="#3-2-栈内存对齐" class="headerlink" title="3.2 栈内存对齐"></a>3.2 栈内存对齐</h4><p>&emsp;&emsp;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。</p>
<p>&emsp;&emsp;【例4】</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)  <span class="comment">//后面可改为1, 2, 4, 8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">long</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span> <span class="title">s</span>;</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a    address:   %p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b    address:   %p\n"</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c    address:   %p\n"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d[0] address:   %p\n"</span>, &amp;(d[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d[1] address:   %p\n"</span>, &amp;(d[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s    address:   %p\n"</span>, &amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s.m2 address:   %p\n"</span>, &amp;(s.m2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果如下：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a    address:   <span class="number">0xbfc4cfff</span></span><br><span class="line">b    address:   <span class="number">0xbfc4cffc</span></span><br><span class="line">c    address:   <span class="number">0xbfc4cff8</span></span><br><span class="line">d[<span class="number">0</span>] address:   <span class="number">0xbfc4cfe8</span></span><br><span class="line">d[<span class="number">1</span>] address:   <span class="number">0xbfc4cff0</span></span><br><span class="line">s    address:   <span class="number">0xbfc4cfe3</span></span><br><span class="line">s.m2 address:   <span class="number">0xbfc4cfe4</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出都是对齐到4字节。并且前面的char和short并没有被凑在一起(成4字节)，这和结构体内的处理是不同的。</p>
<p>&emsp;&emsp;至于为什么输出的地址值是变小的，这是因为该平台下的栈是倒着“生长”的。</p>
<h4 id="3-3-位域对齐"><a href="#3-3-位域对齐" class="headerlink" title="3.3 位域对齐"></a>3.3 位域对齐</h4><h4 id="3-3-1-位域定义"><a href="#3-3-1-位域定义" class="headerlink" title="3.3.1 位域定义"></a>3.3.1 位域定义</h4><p>&emsp;&emsp;有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。</p>
<p>&emsp;&emsp;位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。</p>
<p>&emsp;&emsp;位域定义与结构定义类似，其形式为：</p>
<blockquote>
<p>   struct 位域结构名</p>
<p>  { 位域列表 };</p>
</blockquote>
<p>&emsp;&emsp;其中位域列表的形式为：</p>
<blockquote>
<p>类型说明符位域名：位域长度</p>
</blockquote>
<p>&emsp;&emsp;位域的使用和结构成员的使用相同，其一般形式为：</p>
<blockquote>
<p> 位域变量名.位域名</p>
</blockquote>
<p>&emsp;&emsp;位域允许用各种格式输出。</p>
<p>&emsp;&emsp;位域在本质上就是一种结构类型，不过其成员是按二进位分配的。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。      </p>
<p>&emsp;&emsp;位域的使用主要为下面两种情况：</p>
<p>&emsp;&emsp;1) 当机器可用内存空间较少而使用位域可大量节省内存时。如把结构作为大数组的元素时。</p>
<p>&emsp;&emsp;2) 当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。</p>
<h4 id="3-3-2-对齐准则"><a href="#3-3-2-对齐准则" class="headerlink" title="3.3.2 对齐准则"></a>3.3.2 对齐准则</h4><p>&emsp;&emsp;位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。 </p>
<p>&emsp;&emsp;C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。</p>
<p>&emsp;&emsp;其对齐规则大致为：</p>
<p>&emsp;&emsp;1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</p>
<p>&emsp;&emsp;2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p>
<p>&emsp;&emsp;3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</p>
<p>&emsp;&emsp;4) 如果位域字段之间穿插着非位域字段，则不进行压缩；</p>
<p>&emsp;&emsp;5) 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</p>
<p>&emsp;&emsp;【例5】</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BitField</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  : <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;【例6】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1   : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> element2  : <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">char</span> element3   : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。  </p>
<p>&emsp;&emsp;【例7】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  ;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。   </p>
<p>&emsp;&emsp;【例8】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructBitField</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> element1   : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> element2   : <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> element3   : <span class="number">29</span>;</span><br><span class="line">  <span class="keyword">int</span> element4   : <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">char</span> element5  :<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">char</span> stelement;  <span class="comment">//在含位域的结构或联合中也可同时说明普通成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。</p>
<h4 id="3-3-3-注意事项"><a href="#3-3-3-注意事项" class="headerlink" title="3.3.3 注意事项"></a>3.3.3 注意事项</h4><p>&emsp;&emsp;关于位域操作有几点需要注意：</p>
<p>&emsp;&emsp; 1) 位域的地址不能访问，因此不允许将&amp;运算符用于位域。不能使用指向位域的指针也不能使用位域的数组(数组是种特殊指针)。</p>
<p>&emsp;&emsp; 例如，scanf函数无法直接向位域中存储数据：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span> <span class="title">tBit</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tBit.element2); <span class="comment">//error: cannot take address of bit-field 'element2'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。</p>
<p>&emsp;&emsp;2) 位域不能作为函数返回的结果。</p>
<p> &emsp;&emsp;3) 位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度。例如定义int a:33是不允许的。</p>
<p>&emsp;&emsp;4) 位域可以不指定位域名，但不能访问无名的位域。 </p>
<p> &emsp;&emsp;位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型。例如，char :0表示整个位域向后推一个字节，即该无名位域后的下一个位域从下一个字节开始存放，同理short :0和int :0分别表示整个位域向后推两个和四个字节。</p>
<p> &emsp;&emsp;当空位域的长度为具体数值N时(如int :2)，该变量仅用来占位N位。 </p>
<p> &emsp;&emsp;【例9】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField3</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">char</span>  :<span class="number">6</span>;</span><br><span class="line">  <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp; 结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。 </p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField4</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">char</span>  :<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。</p>
<p> &emsp;&emsp;5) 位域的表示范围。</p>
<ul>
<li>&emsp;&emsp;位域的赋值不能超过其可以表示的范围；</li>
<li>&emsp;&emsp;位域的类型决定该编码能表示的值的结果。</li>
</ul>
<p>&emsp;&emsp;对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据(原码)。如：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;   <span class="comment">//p表示7</span></span><br><span class="line"><span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;            <span class="comment">//p 表示-1，对除符号位之外的所有位取反再加一</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6) 带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。</p>
<p>&emsp;&emsp;【例10】在VC6下执行下面的代码：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">char</span> a : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> b : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c : <span class="number">2</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">    &#125;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input an integer for i(0~15): "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num.i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, cba = %d %d %d\n"</span>, num.i, num.bits.c, num.bits.b, num.bits.a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输入i值为11，则输出为i = 11, cba = -2 -1 -1。</p>
<p>&emsp;&emsp;Intel x86处理器按小字节序存储数据，所以bits中的位域在内存中放置顺序为ccba。当num.i置为11时，bits的最低有效位(即位域a)的值为1，a、b、c按低地址到高地址分别存储为10、1、1(二进制)。</p>
<p>&emsp;&emsp;但为什么最后的打印结果是a=-1而不是1？</p>
<p>&emsp;&emsp;因为位域a定义的类型signed char是有符号数，所以尽管a只有1位，仍要进行符号扩展。1做为补码存在，对应原码-1。</p>
<p>&emsp;&emsp;如果将a、b、c的类型定义为unsigned char，即可得到cba = 2 1 1。1011即为11的二进制数。</p>
<p>&emsp;&emsp;注：C语言中，不同的成员使用共同的存储区域的数据构造类型称为联合(或共用体)。联合占用空间的大小取决于类型长度最大的成员。联合在定义、说明和使用形式上与结构体相似。 </p>
<p>&emsp;&emsp;7) 位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性。因此除非必要否则最好不要使用位域。</p>
<p>&emsp;&emsp;8) 尽管使用位域可以节省内存空间，但却增加了处理时间。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四  总结"></a>四  总结</h3><p>&emsp;&emsp;让我们回到引言部分的问题。</p>
<p>&emsp;&emsp;缺省情况下，C/C++编译器默认将结构、栈中的成员数据进行内存对齐。因此，引言程序输出就变成”c1 -&gt; 0, s -&gt; 2, c2 -&gt; 4, i -&gt; 8”。</p>
<p>&emsp;&emsp;编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致整个结构的尺寸变大。尽管会牺牲一点空间(成员之间有空洞)，但提高了性能。</p>
<p>&emsp;&emsp;也正是这个原因，引言例子中sizeof(T_ FOO)为12，而不是8。 </p>
<p>&emsp;&emsp;总结说来，就是</p>
<blockquote>
<p>&emsp;&emsp;在结构体中，综合考虑变量本身和指定的对齐值；</p>
<p>&emsp;&emsp;在栈上，不考虑变量本身的大小，统一对齐到4字节。</p>
</blockquote>
<h3 id="五-附录"><a href="#五-附录" class="headerlink" title="五  附录"></a>五  附录</h3><h4 id="5-1-字节序与网络序"><a href="#5-1-字节序与网络序" class="headerlink" title="5.1 字节序与网络序"></a>5.1 字节序与网络序</h4><h4 id="5-1-1-字节序"><a href="#5-1-1-字节序" class="headerlink" title="5.1.1 字节序"></a>5.1.1 字节序</h4><p>&emsp;&emsp;字节序，顾名思义就是字节的高低位存放顺序。</p>
<p>&emsp;&emsp;对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。</p>
<p>&emsp;&emsp;对于多字节数据，如整型(32位机中一般占4字节)，在不同的处理器的存放方式主要有两种(以内存中0x0A0B0C0D的存放方式为例)。</p>
<p>&emsp;&emsp;1) 大字节序(Big-Endian，又称大端序或大尾序)</p>
<p>&emsp;&emsp; 在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为大字节序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据以8bit为单位</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">低地址方向</td>
<td style="text-align:center">0x0A</td>
<td style="text-align:center">0x0B</td>
<td style="text-align:center">0x0C</td>
<td style="text-align:center">0x0D</td>
<td style="text-align:center">高地址方向</td>
</tr>
<tr>
<td style="text-align:center">数据以16bit为单位 </td>
</tr>
<tr>
<td style="text-align:center">低地址方向</td>
<td style="text-align:center">0x0A0B</td>
<td style="text-align:center">0x0C0D</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">高地址方向</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp; 其中，最高有效位(MSB，Most Significant Byte)0x0A存储在最低的内存地址处。下个字节0x0B存在后面的地址处。同时，最高的16bit单元0x0A0B存储在低位。</p>
<p>&emsp;&emsp;简而言之，大字节序就是“高字节存入低地址，低字节存入高地址”。</p>
<p>&emsp;&emsp; 这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为Big-endians和Little-endians。</p>
<p>&emsp;&emsp; 1980年，Danny Cohen在其著名的论文”On Holy Wars and a Plea for Peace”中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</p>
<p>&emsp;&emsp; 借用上面的典故，想象一下要把熟鸡蛋旋转着稳立起来，大头(高字节)肯定在下面(低地址) </p>
<p>&emsp;&emsp;2) 小字节序(Little-Endian，又称小端序或小尾序)</p>
<p>&emsp;&emsp;在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为小字节序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据以8bit为单位</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高地址方向</td>
<td style="text-align:center">0x0A</td>
<td style="text-align:center">0x0B</td>
<td style="text-align:center">0x0C</td>
<td style="text-align:center">0x0D</td>
<td style="text-align:center">低地址方向</td>
</tr>
<tr>
<td style="text-align:center">数据以16bit为单位 </td>
</tr>
<tr>
<td style="text-align:center">高地址方向</td>
<td style="text-align:center">0x0A0B</td>
<td style="text-align:center">0x0C0D</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">低地址方向</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;其中，最低有效位(LSB，Least Significant Byte)0x0D存储在最低的内存地址处。后面字节依次存在后面的地址处。同时，最低的16bit单元0x0A0B存储在低位。</p>
<p>&emsp;&emsp;可见，小字节序就是“高字节存入高地址，低字节存入低地址”。 </p>
<p>&emsp;&emsp;C语言中的位域结构也要遵循比特序(类似字节序)。例如：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b: <span class="number">6</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该位域结构占1个字节，假设赋值a = 0x01和b=0x02，则大字节机器上该字节为(01)(000010)，小字节机器上该字节为(000010)(01)。因此在编写可移植代码时，需要加条件编译。</p>
<p>&emsp;&emsp;注意，在包含位域的C结构中，若位域A在位域B之前定义，则位域A所占用的内存空间地址低于位域B所占用的内存空间。</p>
<p>&emsp;&emsp;对上述问题，详细的讲解可参考<a href="http://www.linuxjournal.com/article/6788。" target="_blank" rel="noopener">http://www.linuxjournal.com/article/6788。</a></p>
<p>&emsp;&emsp;另见以下联合体，在小字节机器上若low=0x01，high=0x02，则hex=0x21：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> hex;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> low  : <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> high : <span class="number">4</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;convert;</span><br><span class="line">    convert.low = <span class="number">0x01</span>;</span><br><span class="line">    convert.high = <span class="number">0x02</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hex = 0x%0x\n"</span>, convert.hex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-网络序"><a href="#5-1-2-网络序" class="headerlink" title="5.1.2 网络序"></a>5.1.2 网络序</h4><p>&emsp;&emsp;网络传输一般采用大字节序，也称为网络字节序或网络序。IP协议中定义大字节序为网络字节序。</p>
<p>&emsp;&emsp;对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之(若主机字节序与网络字节序相同，通常将函数定义为空宏)。</p>
<p>&emsp;&emsp;伯克利socket API定义了一组转换函数，用于16和32位整数在网络序和主机字节序之间的转换。Htonl、htons用于主机序转换到网络序；ntohl、ntohs用于网络序转换到本机序。</p>
<p>&emsp;&emsp;注意：在大小字节序转换时，必须考虑待转换数据的长度(如5.1.1节的数据单元)。另外对于单字符或小于单字符的几个bit数据，是不必转换的，因为在机器存储和网络发送的一个字符内的bit位存储顺序是一致的。</p>
<h4 id="5-1-3-位序"><a href="#5-1-3-位序" class="headerlink" title="5.1.3 位序"></a>5.1.3 位序</h4><p>&emsp;&emsp;用于描述串行设备的传输顺序。一般硬件传输采用小字节序(先传低位)，但I2C协议采用大字节序。网络协议中只有数据链路层的底端会涉及到。 </p>
<h4 id="5-1-4-处理器字节序"><a href="#5-1-4-处理器字节序" class="headerlink" title="5.1.4 处理器字节序"></a>5.1.4 处理器字节序</h4><p>&emsp;&emsp;不同处理器体系的字节序如下所示：</p>
<ul>
<li>&emsp;&emsp;X86、MOS Technology 6502、Z80、VAX、PDP-11等处理器为Little endian；</li>
<li>&emsp;&emsp;Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除V9外)等处理器为Big endian；</li>
<li>&emsp;&emsp;ARM、PowerPC (除PowerPC 970外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64等的字节序是可配置的。</li>
</ul>
<h4 id="5-1-5-字节序编程"><a href="#5-1-5-字节序编程" class="headerlink" title="5.1.5 字节序编程"></a>5.1.5 字节序编程</h4><p>&emsp;&emsp;请看下面的语句：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, *((<span class="keyword">short</span>*)<span class="string">"AB"</span>) &gt;&gt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在大字节序下输出为’A’，小字节序下输出为’B’。</p>
<p>&emsp;&emsp;下面的代码可用来判断本地机器字节序： </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line"> <span class="comment">//字节序枚举类型</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">     ENDIAN_LITTLE = (INT8U)<span class="number">0X00</span>,</span><br><span class="line">     ENDIAN_BIG    = (INT8U)<span class="number">0X01</span></span><br><span class="line">  &#125;E_ENDIAN_TYPE;</span><br><span class="line"></span><br><span class="line"> <span class="function">E_ENDIAN_TYPE <span class="title">GetEndianType</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     INT32U dwData = <span class="number">0x12345678</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0x78</span> == *((INT8U*)&amp;dwData))</span><br><span class="line">        <span class="keyword">return</span> ENDIAN_LITTLE;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ENDIAN_BIG;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//Start of GetEndianTypeTest//</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"> <span class="function">VOID <span class="title">GetEndianTypeTest</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> _BYTE_ORDER == _LITTLE_ENDIAN</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n"</span>, __FUNCTION__, </span><br><span class="line">           (ENDIAN_LITTLE != GetEndianType()) ? <span class="string">"ERROR"</span> : <span class="string">"OK"</span>, <span class="string">"Little"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">elif</span> _BYTE_ORDER == _BIG_ENDIAN</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n"</span>, __FUNCTION__, </span><br><span class="line">           (ENDIAN_BIG != GetEndianType()) ? <span class="string">"ERROR"</span> : <span class="string">"OK"</span>, <span class="string">"Big"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//End of GetEndianTypeTest//</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/14/Java中抽象类和接口的用法和区别/" rel="next" title="Java中抽象类和接口的用法和区别">
                <i class="fa fa-chevron-left"></i> Java中抽象类和接口的用法和区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/25/JavaScript中的正则表达式/" rel="prev" title="中的正则表达式">
                中的正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hellen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一-什么是字节对齐"><span class="nav-number">2.</span> <span class="nav-text">一  什么是字节对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-对齐的原因和作用"><span class="nav-number">3.</span> <span class="nav-text">二  对齐的原因和作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-对齐的分类和准则"><span class="nav-number">4.</span> <span class="nav-text">三  对齐的分类和准则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-结构体对齐"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 结构体对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-简单示例"><span class="nav-number">4.2.</span> <span class="nav-text">3.1.1 简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-对齐准则"><span class="nav-number">4.3.</span> <span class="nav-text">3.1.2 对齐准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-对齐的隐患"><span class="nav-number">4.4.</span> <span class="nav-text">3.1.3 对齐的隐患</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-1-数据类型转换"><span class="nav-number">4.5.</span> <span class="nav-text">3.1.3.1 数据类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-2-处理器间数据通信"><span class="nav-number">4.6.</span> <span class="nav-text">3.1.3.2 处理器间数据通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-3-排查对齐问题"><span class="nav-number">4.7.</span> <span class="nav-text">3.1.3.3 排查对齐问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-更改对齐方式"><span class="nav-number">4.8.</span> <span class="nav-text">3.1.4 更改对齐方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-栈内存对齐"><span class="nav-number">4.9.</span> <span class="nav-text">3.2 栈内存对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-位域对齐"><span class="nav-number">4.10.</span> <span class="nav-text">3.3 位域对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-位域定义"><span class="nav-number">4.11.</span> <span class="nav-text">3.3.1 位域定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-对齐准则"><span class="nav-number">4.12.</span> <span class="nav-text">3.3.2 对齐准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-注意事项"><span class="nav-number">4.13.</span> <span class="nav-text">3.3.3 注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-总结"><span class="nav-number">5.</span> <span class="nav-text">四  总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-附录"><span class="nav-number">6.</span> <span class="nav-text">五  附录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-字节序与网络序"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 字节序与网络序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-字节序"><span class="nav-number">6.2.</span> <span class="nav-text">5.1.1 字节序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-网络序"><span class="nav-number">6.3.</span> <span class="nav-text">5.1.2 网络序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-位序"><span class="nav-number">6.4.</span> <span class="nav-text">5.1.3 位序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-处理器字节序"><span class="nav-number">6.5.</span> <span class="nav-text">5.1.4 处理器字节序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-5-字节序编程"><span class="nav-number">6.6.</span> <span class="nav-text">5.1.5 字节序编程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hellen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
