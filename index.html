<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="技术文章记录">
<meta property="og:url" content="https://hellenzhou.github.io/index.html">
<meta property="og:site_name" content="技术文章记录">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术文章记录">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hellenzhou.github.io/"/>





  <title>技术文章记录</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">技术文章记录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2018/01/25/JavaScript的正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/JavaScript的正则表达式/" itemprop="url">JavaScript的正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T19:27:07+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JavaScript-中的正则表达式"><a href="#JavaScript-中的正则表达式" class="headerlink" title="JavaScript 中的正则表达式"></a>JavaScript 中的正则表达式</h2><h3 id="1、-正则表达式概述"><a href="#1、-正则表达式概述" class="headerlink" title="1、 正则表达式概述"></a>1、 正则表达式概述</h3><p>ECMAScript 3 开始支持正则表达式，其语法和 Perl 语法很类似，一个完整的正则表达式结构如下：</p>
<blockquote>
<p>var expression = / pattern / flags ;</p>
</blockquote>
<p>其中，模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。<br>每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为，正则表达式支持下列 3 个标志：</p>
<p>g： 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；<br>i ： 表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；<br>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>如果多个标志同时使用时，则写成：gmi 。</p>
<p>正则表达式的创建有两种方式： new RegExp(expression) 和 直接字面量。</p>
<blockquote>
<p>//使用直接字面量创建</p>
<p>var exp1 = /(^\s+)|(\s+$)/g;</p>
<p>//使用RegExp对象创建</p>
<p>var exp2 = new RegExp(“(^\s+)|(\s+$)”,”g”);</p>
</blockquote>
<p>exp1 和 exp2 是两个完全等价的正则表达式，需要注意的是，传递给 RegExp 构造函数的两个参数都是字符串，不能把正则表达式字面量传递给 RegExp 构造函数。</p>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p>
<blockquote>
<p>( [ { \ ^ $ | ) ? * + .] }<br>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<p>//匹配 .docx</p>
<p>var exp = /.docx/gi ;</p>
</blockquote>
<p>由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。<b>所有元字符都必须双重转义，那些已经转义过的字符也是如此。</b></p>
<blockquote>
<p>// 对 . 再次转义<br>var exp = new RegExp(“\.docx”,”gi”);</p>
<p>//匹配 \n</p>
<p>var exp1 = /\n/g; //对\n中的\转义</p>
<p>var exp2 = new RegExp(“\\n”,”g”); // 对 \n 再次转义</p>
</blockquote>
<h3 id="2、-的区别"><a href="#2、-的区别" class="headerlink" title="2、()  []  {} 的区别"></a>2、()  []  {} 的区别</h3><p>() 的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如 (\s+) 表示连续空格的字符串。</p>
<p>[] 是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示字符文本要匹配英文字符和数字。</p>
<p>{} 一般用来表示匹配的长度，比如 \d{3} 表示匹配三个数字，\d{1,3} 表示匹配1~3个数字，\d{3,} 表示匹配3个以上数字。</p>
<h3 id="3、-与"><a href="#3、-与" class="headerlink" title="3、^ 与$"></a>3、^ 与$</h3><p>^ 匹配一个字符串的开头，比如 (^a) 就是匹配以字母a开头的字符串</p>
<p>$ 匹配一个字符串的结尾,比如 (b$) 就是匹配以字母b结尾的字符串</p>
<p>^ 还有另个一个作用就是取反，比如[^xyz] 表示匹配的字符串不包含xyz</p>
<p>注意问题：</p>
<ul>
<li>如果 ^ 出现在[ ] 中一般表示取反，而出现在其他地方则是匹配字符串的开头。</li>
<li>^ 和 $ 配合可以有效匹配完整字符串: /d+/.test(‘4xpt’) -&gt; true，而 /^\d+$/.test(‘4xpt’)-&gt;false</li>
</ul>
<h3 id="4、-d-s-w"><a href="#4、-d-s-w" class="headerlink" title="4、\d  \s  \w  ."></a>4、\d  \s  \w  .</h3><p>\d 匹配一个非负整数， 等价于 [0-9]</p>
<p>\s 匹配一个空白字符</p>
<p>\w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]</p>
<p>.   匹配除换行符以外的任意字符，等价于[^\n]</p>
<h3 id="5、"><a href="#5、" class="headerlink" title="5、* + ?"></a>5、* + ?</h3><ul>
<li>表示匹配前面元素0次或多次，比如 (\s*) 就是匹配0个或多个空格</li>
</ul>
<ul>
<li>表示匹配前面元素1次或多次，比如 (\d+) 就是匹配由至少1个整数组成的字符串</li>
</ul>
<p>? 表示匹配前面元素0次或1次，相当于{0,1} ，比如(\w?) 就是匹配最多由1个字母或数字组成的字符串</p>
<h3 id="6、-1-与-1"><a href="#6、-1-与-1" class="headerlink" title="6、$1 与 \1"></a>6、$1 与 \1</h3><p>$1-$9 存放着正则表达式中最近的9个正则表达式的提取的结果，这些结果按照子匹配的出现顺序依次排列。基本语法是：RegExp.$n ，这些属性是静态的，除了replace中的第二个参数可以省略 RegExp 之外，其他地方使用都要加上 RegExp 。</p>
<blockquote>
<p>//使用RegExp访问</p>
<p>/(\d+)-(\d+)-(\d+)/.test(“2016-03-26”)</p>
<p>RegExp.$1  // 2016</p>
<p>RegExp.$2  // 03</p>
<p>RegExp.$3  // 26</p>
<p>//在replace中使用</p>
<p>“2016-03-26”.replace(/(\d+)-(\d+)-(\d+)/,”$1年$2月$3日”)</p>
<p>// 2016年03月26日<br>\1 表示后向引用，是指在正则表达式中，从左往右数，第1个()中的内容，以此类推，\2表示第2个()，\0表示整个表达式。</p>
<p>//匹配日期格式，表达式中的\1代表重复(-|\/|.)</p>
<p>var rgx = /\d{4}(-|\/|.)\d{1,2}\1\d{1,2}”/</p>
<p>rgx.test(“2016-03-26”) //true</p>
<p>rgx.test(“2016-03.26”) //false</p>
</blockquote>
<p><b>两者的区别是：\n只能用在表达式中，而$n只能用在表达式之外的地方。 </b></p>
<h3 id="7、test-与-match"><a href="#7、test-与-match" class="headerlink" title="7、test 与 match"></a>7、test 与 match</h3><p>前面的大都是JS正则表达式的语法，而test则是用来检测字符串是否匹配某一个正则表达式，如果匹配就会返回true,反之则返回false</p>
<blockquote>
<p>/\d+/.test(“123”) ; //true</p>
<p>/\d+/.test(“abc”) ; //false</p>
</blockquote>
<p>match是获取正则匹配到的结果，以数组的形式返回</p>
<blockquote>
<p>“186a619b28”.match(/\d+/g); // [“186”,”619”,”28”]</p>
</blockquote>
<h3 id="8、replace"><a href="#8、replace" class="headerlink" title="8、replace"></a>8、replace</h3><p>replace 本身是JavaScript字符串对象的一个方法，它允许接收两个参数：</p>
<blockquote>
<p>replace([RegExp|String],[String|Function])</p>
</blockquote>
<p>第1个参数可以是一个普通的字符串或是一个正则表达式</p>
<p>第2个参数可以是一个普通的字符串或是一个回调函数</p>
<p>如果第1个参数是 RegExp，JS会先提取RegExp匹配出的结果，然后用第2个参数逐一替换匹配出的结果</p>
<p>如果第2个参数是回调函数，每匹配到一个结果就回调一次，每次回调都会传递以下参数：</p>
<blockquote>
<p>result: 本次匹配到的结果</p>
<p>$1,…$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个</p>
<p>offset:记录本次匹配的开始位置</p>
<p>source:接受匹配的原始字符串</p>
</blockquote>
<h3 id="9、经典案例"><a href="#9、经典案例" class="headerlink" title="9、经典案例"></a>9、经典案例</h3><p>####【1】实现字符串的 trim 函数，去除字符串两边的空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line"></span><br><span class="line">//方式一：将匹配到的每一个结果都用&quot;&quot;替换</span><br><span class="line"></span><br><span class="line">return this.replace(/(^\s+)|(\s+$)/g,function()&#123;</span><br><span class="line"></span><br><span class="line">return &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//方式二：和方式一的原理相同</span><br><span class="line"></span><br><span class="line">return this.replace(/(^\s+)|(\s+$)/g,&apos;&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>^\s+ 表示以空格开头的连续空白字符，\s+$ 表示以空格结尾的连续空白字符，加上() 就是将匹配到的结果提取出来，由于是 | 的关系，因此这个表达式最多会match到两个结果集，然后执行两次替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line">/**</span><br><span class="line">* @param rs：匹配结果</span><br><span class="line">* @param $1:第1个()提取结果</span><br><span class="line">* @param $2:第2个()提取结果</span><br><span class="line">* @param offset:匹配开始位置</span><br><span class="line">* @param source：原始字符串</span><br><span class="line">*/</span><br><span class="line">this.replace(/(^\s+)|(\s+$)/g,function(rs,$1,$2,offset,source)&#123;</span><br><span class="line">//arguments中的每个元素对应一个参数</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“ abcd “.trim();</p>
</blockquote>
<p>输出结果：</p>
<blockquote>
<p>[“ “, “ “, undefined, 0, “ abcd “] //第1次匹配结果<br>[“ “, undefined, “ “, 5, “ abcd “] //第2次匹配结果</p>
</blockquote>
<p>####【2】提取浏览器 url 中的参数名和参数值，生成一个key/value 的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getUrlParamObj()&#123;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">//获取url的参数部分</span><br><span class="line">var params = window.location.search.substr(1);</span><br><span class="line">//[^&amp;=]+ 表示不含&amp;或=的连续字符，加上()就是提取对应字符串</span><br><span class="line">params.replace(/([^&amp;=]+)=([^&amp;=]*)/gi,function(rs,$1,$2)&#123;</span><br><span class="line">obj[$1] =  decodeURIComponent($2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>/([^&amp;=]+)=([^&amp;=]*)/gi 每次匹配到的都是一个完整key/value,形如 xxxx=xxx, 每当匹配到一个这样的结果时就执行回调，并传递匹配到的 key 和 value，对应到$1和$2 。</p>
</blockquote>
<p>####【3】扩展 typeof，包含引用类型的具体类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getDataType(obj)&#123;</span><br><span class="line">let rst = Object.prototype.toString.call(obj);</span><br><span class="line">rst = rst.replace(/\[object\s(\w+)\]/,&apos;$1&apos;); //[object Xxx]</span><br><span class="line">return rst.toLowerCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>getDataType(1); //number</p>
<p>getDataType(‘a’); //string</p>
<p>getDataType(null); //null</p>
<p>getDataType([]); //array</p>
</blockquote>
<p>$1 是正则表达式中第一个() 中匹配的内容。需要注意的是，replace的第二个参数只能是字符串或函数，因此，这里的 $1 需要放在引号中。</p>
<p>####【4】在字符串指定位置插入新字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.insetAt = function(str,offset)&#123;</span><br><span class="line"></span><br><span class="line">offset = offset + 1;</span><br><span class="line">//使用RegExp()构造函数创建正则表达式</span><br><span class="line">var regx = new RegExp(&quot;(^.&#123;&quot;+offset+&quot;&#125;)&quot;);</span><br><span class="line"></span><br><span class="line">return this.replace(regx,&quot;$1&quot;+str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“abcd”.insetAt(‘xyz’,2); //在c字符后插入xyz</p>
<p>>>“abcxyzd”</p>
</blockquote>
<p>当offset=2时，正则表达式为：(^.{3})  .表示除\n之外的任意字符，{3} 表示匹配前三个连续字符，加()就会将匹配到的结果提取出来，然后通过replace将匹配到的结果替换为新的字符串，形如：结果=结果+str</p>
<p>####【5】将手机号12988886666转化成129<em>**</em>6666 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function telFormat(tel)&#123;</span><br><span class="line"></span><br><span class="line">tel = String(tel);</span><br><span class="line"></span><br><span class="line">//方式一</span><br><span class="line">return tel.replace(/(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/,function (rs,$1,$2,$3)&#123;</span><br><span class="line">return $1+&quot;****&quot;+$3</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//方式二</span><br><span class="line">return tel.replace(/(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/,&quot;$1****$3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(\d{3}\d{4}\d{4}) 可以匹配完整的手机号，并分别提取前 3 位、4-7 位和 8-11位，”$1<strong><strong>$3” 是将第 2 个匹配结果用</strong></strong>代替并组成新的字符串，然后替换完整的手机号。</p>
<p>####【6】实现HTML编码，将&lt; / &gt; “ &amp; ` 等字符进行转义，避免XSS攻击 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function htmlEncode(str) &#123;</span><br><span class="line">//匹配&lt; / &gt; &quot; &amp; `</span><br><span class="line">return str.replace(/[&lt;&gt;&quot;&amp;\/`]/g, function(rs) &#123;</span><br><span class="line">switch (rs) &#123;</span><br><span class="line">case &quot;&lt;&quot;:</span><br><span class="line">return &quot;&lt;&quot;;</span><br><span class="line">case &quot;&gt;&quot;:</span><br><span class="line">return &quot;&gt;&quot;;</span><br><span class="line">case &quot;&amp;&quot;:</span><br><span class="line">return &quot;&amp;&quot;;</span><br><span class="line">case &quot;\&quot;&quot;:</span><br><span class="line">return &quot;&quot;&quot;;</span><br><span class="line">case &quot;/&quot;:</span><br><span class="line">return &quot;/&quot;</span><br><span class="line">case &quot;`&quot;:</span><br><span class="line">return &quot;&apos;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2017/11/25/字节对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/25/字节对齐/" itemprop="url">字节对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-25T19:38:38+08:00">
                2017-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p> &emsp;&emsp; 考虑下面的结构体定义：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  c1;</span><br><span class="line">   <span class="keyword">short</span> s; </span><br><span class="line">   <span class="keyword">char</span>  c2; </span><br><span class="line">   <span class="keyword">int</span>   i;</span><br><span class="line">&#125;T_FOO;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。</p>
<p> &emsp;&emsp;现在，我们编写一个简单的程序：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    T_FOO a; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1 -&gt; %d, s -&gt; %d, c2 -&gt; %d, i -&gt; %d\n"</span>, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c1 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.s  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.c2 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a, </span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a.i  - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">void</span>*)&amp;a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp; &emsp;&emsp;运行后输出：<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 -&gt; <span class="number">0</span>, s -&gt; <span class="number">2</span>, c2 -&gt; <span class="number">4</span>, i -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;为什么会这样？这就是字节对齐导致的问题。</p>
<p>&emsp;&emsp;本文在参考诸多资料的基础上，详细介绍常见的字节对齐问题。因成文较早，资料来源大多已不可考，敬请谅解。</p>
<h3 id="一-什么是字节对齐"><a href="#一-什么是字节对齐" class="headerlink" title="一  什么是字节对齐"></a>一  什么是字节对齐</h3><p>&emsp;&emsp; 现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</p>
<h3 id="二-对齐的原因和作用"><a href="#二-对齐的原因和作用" class="headerlink" title="二  对齐的原因和作用"></a>二  对齐的原因和作用</h3><p>&emsp;&emsp;不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。</p>
<p>&emsp;&emsp; 但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。</p>
<p>&emsp;&emsp; 因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。</p>
<p>&emsp;&emsp;此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。</p>
<h3 id="三-对齐的分类和准则"><a href="#三-对齐的分类和准则" class="headerlink" title="三  对齐的分类和准则"></a>三  对齐的分类和准则</h3><p>&emsp;&emsp; 主要基于Intel X86架构介绍结构体对齐和栈内存对齐，位域本质上为结构体类型。</p>
<p>&emsp;&emsp; 对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。</p>
<h4 id="3-1-结构体对齐"><a href="#3-1-结构体对齐" class="headerlink" title="3.1 结构体对齐"></a>3.1 结构体对齐</h4><p>&emsp;&emsp;在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</p>
<p>&emsp;&emsp;字节对齐的问题主要就是针对结构体。</p>
<h4 id="3-1-1-简单示例"><a href="#3-1-1-简单示例" class="headerlink" title="3.1.1 简单示例"></a>3.1.1 简单示例</h4><p>&emsp;&emsp;先看个简单的例子(32位，X86处理器，GCC编译器)：</p>
<p>&emsp;&emsp;【例1】设结构体如下定义：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span>    a;</span><br><span class="line">     <span class="keyword">char</span>   b;</span><br><span class="line">     <span class="keyword">short</span>  c;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">     <span class="keyword">char</span>   b;</span><br><span class="line">     <span class="keyword">int</span>    a;</span><br><span class="line">     <span class="keyword">short</span>  c;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？</p>
<p>&emsp;&emsp;结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。 </p>
<p>&emsp;&emsp;结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。 </p>
<h4 id="3-1-2-对齐准则"><a href="#3-1-2-对齐准则" class="headerlink" title="3.1.2 对齐准则"></a>3.1.2 对齐准则</h4><p>&emsp;&emsp;先来看四个重要的基本概念：</p>
<p>&emsp;&emsp;1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。</p>
<p>&emsp;&emsp;2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。</p>
<p>&emsp;&emsp;3) 指定对齐值：#pragma pack (value)时的指定对齐值value。</p>
<p>&emsp;&emsp;4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=<font color="#FF7F50">min{自身对齐值，当前指定的pack值}。</font></p>
<p>&emsp;&emsp;基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。</p>
<p>&emsp;&emsp;其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。</p>
<p>&emsp;&emsp;以此分析3.1.1节中的结构体B：</p>
<p>&emsp;&emsp;假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。</p>
<p>&emsp;&emsp;再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)=12。</p>
<p>&emsp;&emsp;之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。 </p>
<p>&emsp;&emsp;上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。</p>
<p>&emsp;&emsp;结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：</p>
<p>&emsp;&emsp;<font color="#FF7F50">1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</font></p>
<p>&emsp;&emsp;对于以上规则的说明如下：</p>
<p>&emsp;&emsp;<font color="#FF7F50">第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</font></p>
<p>&emsp;&emsp;<font color="#FF7F50">第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</font></p>
<p>&emsp;&emsp;【例2】假设4字节对齐，以下程序的输出结果是多少？</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OFFSET宏定义可取得指定结构体某成员在结构体内部的偏移 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  a;</span><br><span class="line">   <span class="keyword">short</span> b;</span><br><span class="line">   <span class="keyword">char</span>  c;</span><br><span class="line">   <span class="keyword">int</span>   d;</span><br><span class="line">  <span class="keyword">char</span>  e[<span class="number">3</span>];</span><br><span class="line">&#125;T_Test;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Size = %d\n  a-%d, b-%d, c-%d, d-%d\n  e[0]-%d, e[1]-%d, e[2]-%d\n"</span>,</span><br><span class="line">          <span class="keyword">sizeof</span>(T_Test), OFFSET(T_Test, a), OFFSET(T_Test, b),</span><br><span class="line">          OFFSET(T_Test, c), OFFSET(T_Test, d), OFFSET(T_Test, e[<span class="number">0</span>]),</span><br><span class="line">         OFFSET(T_Test, e[<span class="number">1</span>]),OFFSET(T_Test, e[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 执行后输出如下：   </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size = <span class="number">16</span></span><br><span class="line">a<span class="number">-0</span>, b<span class="number">-2</span>, c<span class="number">-4</span>, d<span class="number">-8</span></span><br><span class="line">e[<span class="number">0</span>]<span class="number">-12</span>, e[<span class="number">1</span>]<span class="number">-13</span>, e[<span class="number">2</span>]<span class="number">-14</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面来具体分析：</p>
<p>&emsp;&emsp;首先char a占用1个字节，没问题。</p>
<p>&emsp;&emsp;short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。</p>
<p>&emsp;&emsp;char c占用1个字节，没问题。</p>
<p>&emsp;&emsp;int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。</p>
<p>&emsp;&emsp;char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。</p>
<p>&emsp;&emsp;因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。</p>
<h4 id="3-1-3-对齐的隐患"><a href="#3-1-3-对齐的隐患" class="headerlink" title="3.1.3 对齐的隐患"></a>3.1.3 对齐的隐患</h4><h4 id="3-1-3-1-数据类型转换"><a href="#3-1-3-1-数据类型转换" class="headerlink" title="3.1.3.1 数据类型转换"></a>3.1.3.1 数据类型转换</h4><p>&emsp;&emsp;代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line">         </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">      *p = <span class="number">0x00</span>;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> *p1 = (<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">      *p1 = <span class="number">0x0000</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。</p>
<p>&emsp;&emsp;又如对于3.1.1节的结构体struct B，定义如下函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">       <span class="comment">//Code</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在函数体内如果直接访问p-&gt;a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p-&gt;a的地址很可能不是4的倍数。</p>
<p>&emsp;&emsp;如果p的地址不在对齐边界上就可能出问题，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。 </p>
<p>&emsp;&emsp;解决方式如下：<br>&emsp;&emsp;1) 定义一个此结构的局部变量，用memmove方式将数据拷贝进来。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(struct B *p)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">tData</span>;</span></span><br><span class="line">   memmove(&amp;tData, p, <span class="keyword">sizeof</span>(struct B));</span><br><span class="line">  <span class="comment">//此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定(比如跨CPU输入数据、或指针移位运算出来的数据要特别小心)，则需要这样处理。</p>
<p>&emsp;&emsp;2) 用#pragma pack (1)将STRUCT_T定义为1字节对齐方式。</p>
<h4 id="3-1-3-2-处理器间数据通信"><a href="#3-1-3-2-处理器间数据通信" class="headerlink" title="3.1.3.2 处理器间数据通信"></a>3.1.3.2 处理器间数据通信</h4><p>&emsp;&emsp;处理器间通过消息(对于C/C++而言就是结构体)进行通信时，需要注意字节对齐以及字节序的问题。</p>
<p>&emsp;&emsp;大多数编译器提供内存对其的选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如C/C++编译器提供的#pragma pack(n) n=1，2，4等，让编译器在生成目标文件时，使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处。</p>
<p>&emsp;&emsp;然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。 </p>
<p>&emsp;&emsp;下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。</p>
<p>&emsp;&emsp;对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。</p>
<p>&emsp;&emsp;对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行四字节对齐。</p>
<p>&emsp;&emsp;数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。顺序安排原则是：四字节的放在最前面，两字节的紧接最后一个四字节成员，一字节紧接最后一个两字节成员，填充字节放在最后。</p>
<p>&emsp;&emsp;举例如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_T_MSG</span>&#123;</span></span><br><span class="line">     <span class="keyword">long</span>  ParaA;</span><br><span class="line">     <span class="keyword">long</span>  ParaB;</span><br><span class="line">     <span class="keyword">short</span> ParaC；</span><br><span class="line">     <span class="keyword">char</span>  ParaD;</span><br><span class="line">     <span class="keyword">char</span>  Pad;   <span class="comment">//填充字节</span></span><br><span class="line"> &#125;T_MSG;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-3-排查对齐问题"><a href="#3-1-3-3-排查对齐问题" class="headerlink" title="3.1.3.3 排查对齐问题"></a>3.1.3.3 排查对齐问题</h4><p>&emsp;&emsp;如果出现对齐或者赋值问题可查看：</p>
<p>&emsp;&emsp;1) 编译器的字节序大小端设置；</p>
<p>&emsp;&emsp;2) 处理器架构本身是否支持非对齐访问；</p>
<p>&emsp;&emsp;3) 如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 </p>
<h4 id="3-1-4-更改对齐方式"><a href="#3-1-4-更改对齐方式" class="headerlink" title="3.1.4 更改对齐方式"></a>3.1.4 更改对齐方式</h4><p>&emsp;&emsp;主要是更改C编译器的缺省字节对齐方式。   </p>
<p>&emsp;&emsp; 在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p>
<p>&emsp;&emsp;使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；<br>&emsp;&emsp;使用伪指令#pragma pack()： 取消自定义字节对齐方式。<br>&emsp;&emsp;另外，还有如下的一种方式(GCC特有语法)：</p>
<ul>
<li>&emsp;&emsp;__attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。</li>
<li>&emsp;&emsp;<strong>attribute</strong> ((packed))： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</li>
</ul>
<p>&emsp;&emsp;【注】<strong>attribute</strong>机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。详细介绍请参考：</p>
<p>  &emsp;&emsp;<a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html" target="_blank" rel="noopener">http://www.unixwiz.net/techtips/gnu-c-attributes.html</a></p>
<p>&emsp;&emsp;下面具体针对MS VC/C++ 6.0编译器介绍下如何修改编译器默认对齐值。</p>
<p> &emsp;&emsp;1) VC/C++ IDE环境中，可在[Project]|[Settings]，C/C++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</p>
<p>&emsp;&emsp;&emsp;&emsp;<img src="/2017/11/25/字节对齐/181344177568936.jpg" alt=""></p>
<p>&emsp;&emsp;VC/C++中的编译选项有/Zp[1|2|4|8|16]，/Zpn表示以n字节边界对齐。n字节边界对齐是指一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。亦即：min(sizeof(member), n)。</p>
<p>&emsp;&emsp;实际上，1字节边界对齐也就表示结构成员之间没有空洞。</p>
<p>&emsp;&emsp;/Zpn选项应用于整个工程，影响所有参与编译的结构体。在Struct member alignment中可选择不同的对齐值来改变编译选项。</p>
<p>&emsp;&emsp;2) 在编码时，可用#pragma pack动态修改对齐值。具体语法说明见附录5.3节。</p>
<p>&emsp;&emsp;自定义对齐值后要用#pragma pack()来还原，否则会对后面的结构造成影响。 </p>
<p>&emsp;&emsp;【例3】分析如下结构体C：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">pragma</span> pack(2)  <span class="comment">//指定按2字节对齐</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">      <span class="keyword">char</span>  b;</span><br><span class="line">      <span class="keyword">int</span>   a;</span><br><span class="line">      <span class="keyword">short</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">//取消指定对齐，恢复缺省对齐</span></span></span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;变量b自身对齐值为<span class="number">1</span>，指定对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">1</span>，假设C从<span class="number">0x0000</span>开始，则b存放在<span class="number">0x0000</span>，符合<span class="number">0x0000</span>%<span class="number">1</span>= <span class="number">0</span>；变量a自身对齐值为<span class="number">4</span>，指定对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">2</span>，顺序存放在<span class="number">0x0002</span>~<span class="number">0x0005</span>四个连续字节中，符合<span class="number">0x0002</span>%<span class="number">2</span>=<span class="number">0</span>。变量c的自身对齐值为<span class="number">2</span>，所以有效对齐值为<span class="number">2</span>，顺序存放在<span class="number">0x0006</span>~<span class="number">0x0007</span>中，符合 <span class="number">0x0006</span>%<span class="number">2</span>=<span class="number">0</span>。所以从<span class="number">0x0000</span>到<span class="number">0x00007</span>共八字节存放的是C的变量。C的自身对齐值为<span class="number">4</span>，所以其有效对齐值为<span class="number">2</span>。又<span class="number">8</span>%<span class="number">2</span>=<span class="number">0</span>，C只占用<span class="number">0x0000</span>~<span class="number">0x0007</span>的八个字节。所以<span class="keyword">sizeof</span>(struct C) = <span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;注意，结构体对齐到的字节数并非完全取决于当前指定的pack值，如下：</span><br><span class="line"> </span><br><span class="line"> ```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">      <span class="keyword">char</span>  b;</span><br><span class="line">      <span class="keyword">short</span> a;</span><br><span class="line">      <span class="keyword">char</span>  c;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时sizeof(struct C)的值为7。</p>
<h4 id="3-2-栈内存对齐"><a href="#3-2-栈内存对齐" class="headerlink" title="3.2 栈内存对齐"></a>3.2 栈内存对齐</h4><p>&emsp;&emsp;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。</p>
<p>&emsp;&emsp;【例4】</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)  <span class="comment">//后面可改为1, 2, 4, 8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">long</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StrtE</span> <span class="title">s</span>;</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a    address:   %p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b    address:   %p\n"</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c    address:   %p\n"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d[0] address:   %p\n"</span>, &amp;(d[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d[1] address:   %p\n"</span>, &amp;(d[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s    address:   %p\n"</span>, &amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s.m2 address:   %p\n"</span>, &amp;(s.m2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果如下：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a    address:   <span class="number">0xbfc4cfff</span></span><br><span class="line">b    address:   <span class="number">0xbfc4cffc</span></span><br><span class="line">c    address:   <span class="number">0xbfc4cff8</span></span><br><span class="line">d[<span class="number">0</span>] address:   <span class="number">0xbfc4cfe8</span></span><br><span class="line">d[<span class="number">1</span>] address:   <span class="number">0xbfc4cff0</span></span><br><span class="line">s    address:   <span class="number">0xbfc4cfe3</span></span><br><span class="line">s.m2 address:   <span class="number">0xbfc4cfe4</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出都是对齐到4字节。并且前面的char和short并没有被凑在一起(成4字节)，这和结构体内的处理是不同的。</p>
<p>&emsp;&emsp;至于为什么输出的地址值是变小的，这是因为该平台下的栈是倒着“生长”的。</p>
<h4 id="3-3-位域对齐"><a href="#3-3-位域对齐" class="headerlink" title="3.3 位域对齐"></a>3.3 位域对齐</h4><h4 id="3-3-1-位域定义"><a href="#3-3-1-位域定义" class="headerlink" title="3.3.1 位域定义"></a>3.3.1 位域定义</h4><p>&emsp;&emsp;有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。</p>
<p>&emsp;&emsp;位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。</p>
<p>&emsp;&emsp;位域定义与结构定义类似，其形式为：</p>
<blockquote>
<p>   struct 位域结构名</p>
<p>  { 位域列表 };</p>
</blockquote>
<p>&emsp;&emsp;其中位域列表的形式为：</p>
<blockquote>
<p>类型说明符位域名：位域长度</p>
</blockquote>
<p>&emsp;&emsp;位域的使用和结构成员的使用相同，其一般形式为：</p>
<blockquote>
<p> 位域变量名.位域名</p>
</blockquote>
<p>&emsp;&emsp;位域允许用各种格式输出。</p>
<p>&emsp;&emsp;位域在本质上就是一种结构类型，不过其成员是按二进位分配的。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。      </p>
<p>&emsp;&emsp;位域的使用主要为下面两种情况：</p>
<p>&emsp;&emsp;1) 当机器可用内存空间较少而使用位域可大量节省内存时。如把结构作为大数组的元素时。</p>
<p>&emsp;&emsp;2) 当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。</p>
<h4 id="3-3-2-对齐准则"><a href="#3-3-2-对齐准则" class="headerlink" title="3.3.2 对齐准则"></a>3.3.2 对齐准则</h4><p>&emsp;&emsp;位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。 </p>
<p>&emsp;&emsp;C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。</p>
<p>&emsp;&emsp;其对齐规则大致为：</p>
<p>&emsp;&emsp;1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</p>
<p>&emsp;&emsp;2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p>
<p>&emsp;&emsp;3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</p>
<p>&emsp;&emsp;4) 如果位域字段之间穿插着非位域字段，则不进行压缩；</p>
<p>&emsp;&emsp;5) 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</p>
<p>&emsp;&emsp;【例5】</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BitField</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  : <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;【例6】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1   : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> element2  : <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">char</span> element3   : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。  </p>
<p>&emsp;&emsp;【例7】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> element2  ;</span><br><span class="line">    <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。   </p>
<p>&emsp;&emsp;【例8】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructBitField</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> element1   : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> element2   : <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> element3   : <span class="number">29</span>;</span><br><span class="line">  <span class="keyword">int</span> element4   : <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">char</span> element5  :<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">char</span> stelement;  <span class="comment">//在含位域的结构或联合中也可同时说明普通成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。</p>
<h4 id="3-3-3-注意事项"><a href="#3-3-3-注意事项" class="headerlink" title="3.3.3 注意事项"></a>3.3.3 注意事项</h4><p>&emsp;&emsp;关于位域操作有几点需要注意：</p>
<p>&emsp;&emsp; 1) 位域的地址不能访问，因此不允许将&amp;运算符用于位域。不能使用指向位域的指针也不能使用位域的数组(数组是种特殊指针)。</p>
<p>&emsp;&emsp; 例如，scanf函数无法直接向位域中存储数据：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitField1</span> <span class="title">tBit</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tBit.element2); <span class="comment">//error: cannot take address of bit-field 'element2'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。</p>
<p>&emsp;&emsp;2) 位域不能作为函数返回的结果。</p>
<p> &emsp;&emsp;3) 位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度。例如定义int a:33是不允许的。</p>
<p>&emsp;&emsp;4) 位域可以不指定位域名，但不能访问无名的位域。 </p>
<p> &emsp;&emsp;位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型。例如，char :0表示整个位域向后推一个字节，即该无名位域后的下一个位域从下一个字节开始存放，同理short :0和int :0分别表示整个位域向后推两个和四个字节。</p>
<p> &emsp;&emsp;当空位域的长度为具体数值N时(如int :2)，该变量仅用来占位N位。 </p>
<p> &emsp;&emsp;【例9】</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField3</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">char</span>  :<span class="number">6</span>;</span><br><span class="line">  <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp; 结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。 </p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField4</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> element1  : <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">char</span>  :<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> element3  : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。</p>
<p> &emsp;&emsp;5) 位域的表示范围。</p>
<ul>
<li>&emsp;&emsp;位域的赋值不能超过其可以表示的范围；</li>
<li>&emsp;&emsp;位域的类型决定该编码能表示的值的结果。</li>
</ul>
<p>&emsp;&emsp;对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据(原码)。如：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;   <span class="comment">//p表示7</span></span><br><span class="line"><span class="keyword">int</span> p:<span class="number">3</span> = <span class="number">111</span>;            <span class="comment">//p 表示-1，对除符号位之外的所有位取反再加一</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6) 带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。</p>
<p>&emsp;&emsp;【例10】在VC6下执行下面的代码：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">char</span> a : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> b : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c : <span class="number">2</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">    &#125;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input an integer for i(0~15): "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num.i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, cba = %d %d %d\n"</span>, num.i, num.bits.c, num.bits.b, num.bits.a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输入i值为11，则输出为i = 11, cba = -2 -1 -1。</p>
<p>&emsp;&emsp;Intel x86处理器按小字节序存储数据，所以bits中的位域在内存中放置顺序为ccba。当num.i置为11时，bits的最低有效位(即位域a)的值为1，a、b、c按低地址到高地址分别存储为10、1、1(二进制)。</p>
<p>&emsp;&emsp;但为什么最后的打印结果是a=-1而不是1？</p>
<p>&emsp;&emsp;因为位域a定义的类型signed char是有符号数，所以尽管a只有1位，仍要进行符号扩展。1做为补码存在，对应原码-1。</p>
<p>&emsp;&emsp;如果将a、b、c的类型定义为unsigned char，即可得到cba = 2 1 1。1011即为11的二进制数。</p>
<p>&emsp;&emsp;注：C语言中，不同的成员使用共同的存储区域的数据构造类型称为联合(或共用体)。联合占用空间的大小取决于类型长度最大的成员。联合在定义、说明和使用形式上与结构体相似。 </p>
<p>&emsp;&emsp;7) 位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性。因此除非必要否则最好不要使用位域。</p>
<p>&emsp;&emsp;8) 尽管使用位域可以节省内存空间，但却增加了处理时间。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四  总结"></a>四  总结</h3><p>&emsp;&emsp;让我们回到引言部分的问题。</p>
<p>&emsp;&emsp;缺省情况下，C/C++编译器默认将结构、栈中的成员数据进行内存对齐。因此，引言程序输出就变成”c1 -&gt; 0, s -&gt; 2, c2 -&gt; 4, i -&gt; 8”。</p>
<p>&emsp;&emsp;编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致整个结构的尺寸变大。尽管会牺牲一点空间(成员之间有空洞)，但提高了性能。</p>
<p>&emsp;&emsp;也正是这个原因，引言例子中sizeof(T_ FOO)为12，而不是8。 </p>
<p>&emsp;&emsp;总结说来，就是</p>
<blockquote>
<p>&emsp;&emsp;在结构体中，综合考虑变量本身和指定的对齐值；</p>
<p>&emsp;&emsp;在栈上，不考虑变量本身的大小，统一对齐到4字节。</p>
</blockquote>
<h3 id="五-附录"><a href="#五-附录" class="headerlink" title="五  附录"></a>五  附录</h3><h4 id="5-1-字节序与网络序"><a href="#5-1-字节序与网络序" class="headerlink" title="5.1 字节序与网络序"></a>5.1 字节序与网络序</h4><h4 id="5-1-1-字节序"><a href="#5-1-1-字节序" class="headerlink" title="5.1.1 字节序"></a>5.1.1 字节序</h4><p>&emsp;&emsp;字节序，顾名思义就是字节的高低位存放顺序。</p>
<p>&emsp;&emsp;对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。</p>
<p>&emsp;&emsp;对于多字节数据，如整型(32位机中一般占4字节)，在不同的处理器的存放方式主要有两种(以内存中0x0A0B0C0D的存放方式为例)。</p>
<p>&emsp;&emsp;1) 大字节序(Big-Endian，又称大端序或大尾序)</p>
<p>&emsp;&emsp; 在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为大字节序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据以8bit为单位</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">低地址方向</td>
<td style="text-align:center">0x0A</td>
<td style="text-align:center">0x0B</td>
<td style="text-align:center">0x0C</td>
<td style="text-align:center">0x0D</td>
<td style="text-align:center">高地址方向</td>
</tr>
<tr>
<td style="text-align:center">数据以16bit为单位 </td>
</tr>
<tr>
<td style="text-align:center">低地址方向</td>
<td style="text-align:center">0x0A0B</td>
<td style="text-align:center">0x0C0D</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">高地址方向</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp; 其中，最高有效位(MSB，Most Significant Byte)0x0A存储在最低的内存地址处。下个字节0x0B存在后面的地址处。同时，最高的16bit单元0x0A0B存储在低位。</p>
<p>&emsp;&emsp;简而言之，大字节序就是“高字节存入低地址，低字节存入高地址”。</p>
<p>&emsp;&emsp; 这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为Big-endians和Little-endians。</p>
<p>&emsp;&emsp; 1980年，Danny Cohen在其著名的论文”On Holy Wars and a Plea for Peace”中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</p>
<p>&emsp;&emsp; 借用上面的典故，想象一下要把熟鸡蛋旋转着稳立起来，大头(高字节)肯定在下面(低地址) </p>
<p>&emsp;&emsp;2) 小字节序(Little-Endian，又称小端序或小尾序)</p>
<p>&emsp;&emsp;在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为小字节序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据以8bit为单位</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高地址方向</td>
<td style="text-align:center">0x0A</td>
<td style="text-align:center">0x0B</td>
<td style="text-align:center">0x0C</td>
<td style="text-align:center">0x0D</td>
<td style="text-align:center">低地址方向</td>
</tr>
<tr>
<td style="text-align:center">数据以16bit为单位 </td>
</tr>
<tr>
<td style="text-align:center">高地址方向</td>
<td style="text-align:center">0x0A0B</td>
<td style="text-align:center">0x0C0D</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">低地址方向</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;其中，最低有效位(LSB，Least Significant Byte)0x0D存储在最低的内存地址处。后面字节依次存在后面的地址处。同时，最低的16bit单元0x0A0B存储在低位。</p>
<p>&emsp;&emsp;可见，小字节序就是“高字节存入高地址，低字节存入低地址”。 </p>
<p>&emsp;&emsp;C语言中的位域结构也要遵循比特序(类似字节序)。例如：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b: <span class="number">6</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该位域结构占1个字节，假设赋值a = 0x01和b=0x02，则大字节机器上该字节为(01)(000010)，小字节机器上该字节为(000010)(01)。因此在编写可移植代码时，需要加条件编译。</p>
<p>&emsp;&emsp;注意，在包含位域的C结构中，若位域A在位域B之前定义，则位域A所占用的内存空间地址低于位域B所占用的内存空间。</p>
<p>&emsp;&emsp;对上述问题，详细的讲解可参考<a href="http://www.linuxjournal.com/article/6788。" target="_blank" rel="noopener">http://www.linuxjournal.com/article/6788。</a></p>
<p>&emsp;&emsp;另见以下联合体，在小字节机器上若low=0x01，high=0x02，则hex=0x21：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> hex;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> low  : <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> high : <span class="number">4</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;convert;</span><br><span class="line">    convert.low = <span class="number">0x01</span>;</span><br><span class="line">    convert.high = <span class="number">0x02</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hex = 0x%0x\n"</span>, convert.hex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-网络序"><a href="#5-1-2-网络序" class="headerlink" title="5.1.2 网络序"></a>5.1.2 网络序</h4><p>&emsp;&emsp;网络传输一般采用大字节序，也称为网络字节序或网络序。IP协议中定义大字节序为网络字节序。</p>
<p>&emsp;&emsp;对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之(若主机字节序与网络字节序相同，通常将函数定义为空宏)。</p>
<p>&emsp;&emsp;伯克利socket API定义了一组转换函数，用于16和32位整数在网络序和主机字节序之间的转换。Htonl、htons用于主机序转换到网络序；ntohl、ntohs用于网络序转换到本机序。</p>
<p>&emsp;&emsp;注意：在大小字节序转换时，必须考虑待转换数据的长度(如5.1.1节的数据单元)。另外对于单字符或小于单字符的几个bit数据，是不必转换的，因为在机器存储和网络发送的一个字符内的bit位存储顺序是一致的。</p>
<h4 id="5-1-3-位序"><a href="#5-1-3-位序" class="headerlink" title="5.1.3 位序"></a>5.1.3 位序</h4><p>&emsp;&emsp;用于描述串行设备的传输顺序。一般硬件传输采用小字节序(先传低位)，但I2C协议采用大字节序。网络协议中只有数据链路层的底端会涉及到。 </p>
<h4 id="5-1-4-处理器字节序"><a href="#5-1-4-处理器字节序" class="headerlink" title="5.1.4 处理器字节序"></a>5.1.4 处理器字节序</h4><p>&emsp;&emsp;不同处理器体系的字节序如下所示：</p>
<ul>
<li>&emsp;&emsp;X86、MOS Technology 6502、Z80、VAX、PDP-11等处理器为Little endian；</li>
<li>&emsp;&emsp;Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除V9外)等处理器为Big endian；</li>
<li>&emsp;&emsp;ARM、PowerPC (除PowerPC 970外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64等的字节序是可配置的。</li>
</ul>
<h4 id="5-1-5-字节序编程"><a href="#5-1-5-字节序编程" class="headerlink" title="5.1.5 字节序编程"></a>5.1.5 字节序编程</h4><p>&emsp;&emsp;请看下面的语句：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, *((<span class="keyword">short</span>*)<span class="string">"AB"</span>) &gt;&gt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在大字节序下输出为’A’，小字节序下输出为’B’。</p>
<p>&emsp;&emsp;下面的代码可用来判断本地机器字节序： </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line"> <span class="comment">//字节序枚举类型</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">     ENDIAN_LITTLE = (INT8U)<span class="number">0X00</span>,</span><br><span class="line">     ENDIAN_BIG    = (INT8U)<span class="number">0X01</span></span><br><span class="line">  &#125;E_ENDIAN_TYPE;</span><br><span class="line"></span><br><span class="line"> <span class="function">E_ENDIAN_TYPE <span class="title">GetEndianType</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     INT32U dwData = <span class="number">0x12345678</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0x78</span> == *((INT8U*)&amp;dwData))</span><br><span class="line">        <span class="keyword">return</span> ENDIAN_LITTLE;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ENDIAN_BIG;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//Start of GetEndianTypeTest//</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"> <span class="function">VOID <span class="title">GetEndianTypeTest</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> _BYTE_ORDER == _LITTLE_ENDIAN</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n"</span>, __FUNCTION__, </span><br><span class="line">           (ENDIAN_LITTLE != GetEndianType()) ? <span class="string">"ERROR"</span> : <span class="string">"OK"</span>, <span class="string">"Little"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">elif</span> _BYTE_ORDER == _BIG_ENDIAN</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n"</span>, __FUNCTION__, </span><br><span class="line">           (ENDIAN_BIG != GetEndianType()) ? <span class="string">"ERROR"</span> : <span class="string">"OK"</span>, <span class="string">"Big"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//End of GetEndianTypeTest//</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2017/10/14/Java中抽象类和接口的用法和区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Java中抽象类和接口的用法和区别/" itemprop="url">Java中抽象类和接口的用法和区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T11:18:33+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h4><p>1、抽象类</p>
<p>包含一个抽象方法的类就是抽象类</p>
<p>2、抽象方法</p>
<p>声明而未被实现的方法，抽象方法必须使用abstract关键词字声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  public abstract class People &#123;  //关键词abstract，声明该类为抽象类</span><br><span class="line">    public int age;</span><br><span class="line">    public void Num() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract Name(); //声明该方法为抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法</p>
<p>4、抽象类不能被直接实例化，要通过其子类进行实例化</p>
<p>5、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</p>
<p>6、子类中的抽象方法不能与父类的抽象方法同名。</p>
<p>7、abstract不能与final并列修饰同一个类。</p>
<p>8、abstract 不能与private、static、final或native并列修饰同一个方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2017/08/11/美丽长滩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/美丽长滩/" itemprop="url">美丽长滩岛</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T14:38:31+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>长滩岛（Boracay）是菲律宾中部的一座岛屿，面积10.32平方公里，人口12,003人（2000年）。属于热带海洋气候，行政区划属西米沙鄢大区的阿克兰省，位于班乃岛西北2公里，是菲律宾的旅游胜地之一。</p>
<p>坐着萌萌的嘟嘟车转圈</p>
<p>中午的太阳还是有点大的</p>
<img src="/2017/08/11/美丽长滩/IMG_0437.jpg">
<p>顺便理个发，入乡随俗了…</p>


<p>路过海边</p>
<img src="/2017/08/11/美丽长滩/IMG_0495.jpg">

<p>海边小村庄里，孩子们在玩耍呢…</p>
<img src="/2017/08/11/美丽长滩/IMG_0530.jpg">
<p>  最爽的莫过于出海浮潜 船开到大海中就停了 导游便开始往海里扔面包屑 大家都开始蠢蠢欲动 会游泳的小伙伴们早就蓄势待发了 我虽然装备都带好…</p>
 <img src="/2017/08/11/美丽长滩/IMG_0472.jpg">
 <img src="/2017/08/11/美丽长滩/IMG_0493.jpg">
<p> 然后发现人家还有长滩的玩耍。选择了一个笑脸伞，虽然坐飞机过去了，但是还是想坐坐笑…</p>
 
<p>  挂在螃蟹船的脚上看夕阳，真是美不胜收。可惜当地的管理不规范，螃蟹船的船主说好看30分钟，不到15分钟就上岸让我们下去又接上新的一波游客。夕阳…</p>
 
<p>  必须推荐，非常刺激！是非常！耍完整个手臂都痛。长滩风浪大，很适合玩这个！被甩进海里整个人都是懵的。我们六个人，5个人都被扔进海里了！最安全…</p>
 <img src="/2017/08/11/美丽长滩/IMG_0476.jpg">
 
 
 <img src="/2017/08/11/美丽长滩/IMG_0501.jpg">
 <img src="/2017/08/11/美丽长滩/IMG_0509.jpg">
<p>日落风帆是长滩特有的特色，而且很好玩，尤其是黄昏日落的时候，很惬意～情侣的话推荐包船</p>
<img src="/2017/08/11/美丽长滩/IMG_0500.jpg">
<p>美丽的黄昏就是好基友，也能看到完美的背影…</p>
<img src="/2017/08/11/美丽长滩/IMG_0510.jpg">


<img src="/2017/08/11/美丽长滩/IMG_0508.jpg"> 
<p>夜晚，本地的酒头晕了….</p>
   
  
<p>山顶的泳池  </p>
 
 <img src="/2017/08/11/美丽长滩/IMG_0453.jpg">
 <img src="/2017/08/11/美丽长滩/IMG_0455.jpg">
<p>回酒店睡个懒觉</p>
 
<p>突然想起白天可爱的小车</p>
 <img src="/2017/08/11/美丽长滩/IMG_0564.jpg">
<p> 和路过的风景</p>
 <img src="/2017/08/11/美丽长滩/IMG_0561.jpg">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellenzhou.github.io/2017/08/03/二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hellen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术文章记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/二叉树/" itemprop="url">二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T16:02:30+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="二叉树的使用场景"><a href="#二叉树的使用场景" class="headerlink" title="二叉树的使用场景"></a>二叉树的使用场景</h4><ul>
<li><p>AVL树:最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树<br>红黑树:平衡二叉树，广泛用在C++的STL中。map和set都是用红黑树实现的。我们熟悉的STL的map容器底层是RBtree,当然指的不是unordered_map,后者是hash。<br>B/B+树用在磁盘文件组织 数据索引和数据库索引<br>Trie树 字典树，用在统计和排序大量字符串</p>
</li>
<li><p>epoll在内核中的实现，用红黑树管理事件块<br>nginx中，用红黑树管理timer等<br>Java的TreeMap实现<br>著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块<br>B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：B-Tree Index in MySql<br>trie 树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示<br>还有比如IP选路，也是前缀匹配，一定程度会用到trie</p>
</li>
<li><p>跳表：Redis中就使用跳表，而不是红黑树来存储管理其中的元素（应该说的是一级元素-直接的Key,里面的value应该是有不同的数据结构）。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hellen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hellen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
